<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>【浅析】Magic Method · Lain</title><meta name="description" content="【浅析】Magic Method - null"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/gandalfr.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/solarized-light.min.css"><link rel="search" type="application/opensearchdescription+xml" href="https://blog.lain.buzz/atom.xml" title="Lain"><meta name="generator" content="Hexo 7.0.0-rc1"><link rel="alternate" href="/atom.xml" title="Lain" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.ico" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/favorites" target="_self" class="nav-list-link">LINK</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="https://web.lain.buzz" target="_blank" class="nav-list-link">FAVORITES</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">【浅析】Magic Method</h1><div class="tags"><a href="/tags/code/" class="tag-title">#code</a><a href="/tags/python/" class="tag-title">#python</a><a href="/tags/Magic-Method/" class="tag-title">#Magic Method</a><a href="/tags/%E6%8F%8F%E8%BF%B0%E5%99%A8/" class="tag-title">#描述器</a></div><div class="post-info">2020年7月15日</div><div class="post-content"><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>本文基本摘自 两点水 的<a href="">草根学Python</a>,本文仅作记录备份或者本人查阅方便，</p>
<span id="more"></span>

<h5 id="了解Magic-Method-魔术方法"><a href="#了解Magic-Method-魔术方法" class="headerlink" title="了解Magic Method(魔术方法)"></a>了解Magic Method(魔术方法)</h5><ul>
<li>双下划线包起来的方法，都统称为”魔术方法”，如”<strong>init</strong>“</li>
<li>使用魔术方法可以构造出优美的代码，将复杂的逻辑封装成简单的方法</li>
<li>使用dir()列出类中所有的魔术方法，如下例</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">dir</span>(User()))<br></code></pre></td></tr></table></figure>

<pre><code>[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;]
</code></pre>
<h5 id="构造-new-和初始化-init"><a href="#构造-new-和初始化-init" class="headerlink" title="构造(new)和初始化(init)"></a>构造(<strong>new</strong>)和初始化(<strong>init</strong>)</h5><ul>
<li>实际上创建类的过程是分为两步的，一步是创建类的对象，还有一部就是对类进行初始化</li>
<li>下方的例子是对类进行初始化操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br>user = User(<span class="hljs-string">&#x27;XiongJum&#x27;</span>, <span class="hljs-number">24</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>new</strong> 是用来创建类并返回这个类的实例，而 <strong>init</strong> 只是将传入的参数来初始化该实例</li>
<li><strong>new</strong> 在创建一个实例的过程中必定会被调用， 但 <strong>init</strong> 就不一定</li>
<li>如通过 pickle.load 的方式反序化一个实例时就不会调用 <strong>init</strong> 方法 <font color=red>反序列化？</font></li>
<li>具体示例如下</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-comment"># 打印 __new__ 方法中的相关信息</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;调用了 def __new__ 方法&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(args)<br>        <span class="hljs-comment"># 最后返回父类的方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(User, cls).__new__(cls)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;调用了 def __init__ 方法&quot;</span>)<br>        self.name = name<br>        self.age = age<br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    user = User(<span class="hljs-string">&#x27;XiongJum&#x27;</span>, <span class="hljs-number">23</span>)<br></code></pre></td></tr></table></figure>

<pre><code>调用了 def __new__ 方法
(&#39;XiongJum&#39;, 23)
调用了 def __init__ 方法
</code></pre>
<ul>
<li>通过上图示例可得知，创建一个类，先是调用了 <strong>new</strong> 方法来创建一个对象，把参数传给 __init__，并进行实例化</li>
<li>但是在实际的开发中，很少会用到__new__ 方法，除非希望能够控制类的创建。</li>
</ul>
<h5 id="属性的访问控制"><a href="#属性的访问控制" class="headerlink" title="属性的访问控制"></a>属性的访问控制</h5><ul>
<li>_<em>getattr</em>_(self, name): <ul>
<li>定义了试图访问不存在的属性时的行为</li>
<li>所以重载该方法可以实现捕获错误拼写然后进行重定向，或者对一些废弃的属性进行警告</li>
</ul>
</li>
<li>_<em>setattr</em>_(self, name, value):<ul>
<li>定义了对属性进行赋值和修改操作时的行为。</li>
<li>不管对象的某个属性是否存在，都允许为该属性进行赋值(如下例的attr1)，但要避免”无限递归”的错误</li>
</ul>
</li>
<li>_<em>delattr</em>_(self, name):<ul>
<li><strong>delattr</strong> 与 <strong>setattr</strong> 很像，但它只定义的时你删除属性时的行为</li>
<li>和 <strong>setattr</strong> 一样，要避免”无限递归”的错误</li>
</ul>
</li>
<li>_<em>getattribute</em>_(self, name):<ul>
<li>定义了你的属性被访问时的行为，相比与只有该属性不存在时才会起作用的 _<em>getattr__，在支持 <strong>getattribute</strong> 的Python版本中，调用 _<em>getattr</em></em> 前必定会调用 __getattribute__。</li>
<li>如果在 <strong>getattribute</strong>(self, name) 方法下存在通过self.name 访问属性, 则会出现无限递归错误，</li>
<li>所以和 <strong>setattr</strong> 一样，要避免”无限递归”的错误</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># def __setattr__(self, name, value):</span><br><span class="hljs-comment">#     self.name = value</span><br>    <br><span class="hljs-comment"># def __setattr__(self, name, value):</span><br><span class="hljs-comment">#     self.__dict__[name] = value</span><br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;调用了 __getattr__ 方法&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(User, self).__getattr__(name)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, name, value</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;调用了 __setattr__ 方法&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(User, self).__setattr__(name, value)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delattr__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;调用了 __delattr__ 方法&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(User, self).__delattr__(name)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;调用了 __getattribute__ 方法&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(User, self).__getattribute__(name)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    user = User()<br>    <span class="hljs-comment"># 设置属性值，会调用 __setattr__</span><br>    user.attr1 = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 属性存在，只有 __getattribute__ 调用</span><br>    user.attr1<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 属性不存在 先调用 __getattribute__，后调用 __getattr__</span><br>        user.attr2<br>    <span class="hljs-keyword">except</span> AttributeError:<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-comment"># 调用 __delattr__</span><br>    <span class="hljs-keyword">del</span> user.attr1<br></code></pre></td></tr></table></figure>

<pre><code>调用了 __setattr__ 方法
调用了 __getattribute__ 方法
调用了 __getattribute__ 方法
调用了 __getattr__ 方法
调用了 __delattr__ 方法
</code></pre>
<h5 id="对象的描述器"><a href="#对象的描述器" class="headerlink" title="对象的描述器"></a>对象的描述器</h5><ul>
<li>定义和简介<ul>
<li>一般地，一个描述器是一个包含”绑定行为”的对象,对其属性的访问被描述器协议中定义的方法覆盖。</li>
<li>这些方法有: <strong>get</strong>(), <strong>set</strong>(), <strong>delete</strong>().</li>
<li>如果某个对象中定义了这些方法中的任意一个，那么这个对象就可以被称为一个描述器</li>
<li><font color=red>下例中 MyClass 是如何传入值的？</font></li>
</ul>
</li>
<li>描述器协议<ul>
<li>descr.<strong>get</strong>(self, obj, type&#x3D;None) –&gt; value</li>
<li>descr.<strong>set</strong>(self, obj, value) –&gt; None</li>
<li>descr.<strong>delete</strong>(self, obj) –&gt;None</li>
<li>定义这些方法中的任何一个对象被视为描述器，并在被作为属性时覆盖其默认行为</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name=<span class="hljs-string">&#x27;XiongJum&#x27;</span>, sex=<span class="hljs-string">&#x27;男&#x27;</span></span>):<br>        self.sex = sex<br>        self.name = name<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, obj, objtype</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;获取 name 的值&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self.name<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, obj, val</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;设置 name 的值&#x27;</span>)<br>        self.name = val<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    x = User(<span class="hljs-string">&#x27;XiongJum&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br>    y = <span class="hljs-number">5</span><br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    m = MyClass()<br>    <span class="hljs-built_in">print</span>(m.x, <span class="hljs-string">&#x27;\n&#x27;</span>)<br>    <br>    m.x = <span class="hljs-string">&#x27;酒明&#x27;</span><br>    <span class="hljs-built_in">print</span>(m.x, <span class="hljs-string">&#x27;\n&#x27;</span>)<br>    <br>    <span class="hljs-built_in">print</span>(m.x, <span class="hljs-string">&#x27;\n&#x27;</span>)<br>    <br>    <span class="hljs-built_in">print</span>(m.y)<br></code></pre></td></tr></table></figure>

<pre><code>获取 name 的值
XiongJum 

设置 name 的值
获取 name 的值
酒明 

获取 name 的值
酒明 

5
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value=<span class="hljs-number">0.0</span></span>):<br>        self.value = <span class="hljs-built_in">float</span>(value) <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-keyword">return</span> self.value<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        self.value = <span class="hljs-built_in">float</span>(value)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dis</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    user = User()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>    d = Dis()<br>    <span class="hljs-built_in">print</span>(d.user)<br></code></pre></td></tr></table></figure>

<h5 id="自定义容器"><a href="#自定义容器" class="headerlink" title="自定义容器"></a>自定义容器</h5><ul>
<li>常见的容器类型<ul>
<li>可变容器：dict，list</li>
<li>不可变容器：tuple， string</li>
</ul>
</li>
<li>可变容器和不可变容器的区别<ul>
<li>不可变容器一旦赋值后，就无法对某个元素进行修改</li>
<li>只能重新赋值或者重新覆盖全部的元素</li>
</ul>
</li>
<li>自定义容器<ul>
<li>自定义不可变容器类型： 需要定义 ‘_<em>len</em><em>‘ 和 ‘_<em>getitem</em></em>‘ 方法</li>
<li>自定义可变类型容器： 在不可以容器的基础上，增加定义 ‘_<em>setitem</em><em>‘ 和 ‘_<em>delitem</em></em>‘</li>
<li>自定义的数据类型需要迭代：需要定义 ‘_<em>iter</em>_’</li>
<li>返回自定义容器的长度：需要实现 ‘_<em>len</em>_’(self)</li>
<li>自定义容器可以调用 self(key)，如果 key 类型错误，抛出 TypeError, 如果没法返回 key 对应的数字时，则应该抛出 ValueError：<br>需要实现 ‘_<em>getitem</em>_(self, key)’</li>
<li>当执行 self[key] &#x3D; value 时 ： 调用 ‘_<em>setitem</em>_(self, key, value)’ 方法</li>
<li>当执行 del self[key] 方法：调用的方法时 ‘_<em>delitem</em>_’(self, key)</li>
<li>当你想你的容器可以执行 for x in container：或者使用 iter(container) 时：需实现 ‘_<em>iter</em>_(self)’,该方法返回的是一个迭代器</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FunctionalList</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;实现内置类型list的功能，并丰富了一些其余的方法：head, init, last, drop, take&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, values=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">if</span> values <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.values = []<br>        <span class="hljs-keyword">else</span>:<br>            self.values = values<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.values)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-keyword">return</span> self.values[key]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):<br>        self.values[key] = value<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delitem__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-keyword">del</span> self.values[key]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>(self.values)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reversed__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> FunctionalList(<span class="hljs-built_in">reversed</span>(self.values))<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">append</span>(<span class="hljs-params">self, value</span>):<br>        self.values.append(value)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">head</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 获取第一个元素</span><br>        <span class="hljs-keyword">return</span> self.values[<span class="hljs-number">0</span>]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 获取最后一个元素之外的所有元素</span><br>        <span class="hljs-keyword">return</span> self.values[:-<span class="hljs-number">1</span>]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">last</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 获取最后一个元素</span><br>        <span class="hljs-keyword">return</span> self.values[-<span class="hljs-number">1</span>]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">drop</span>(<span class="hljs-params">self, n</span>):<br>        <span class="hljs-comment"># 获取第n个元素之后的元素</span><br>        <span class="hljs-keyword">return</span> self.values[n:]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">take</span>(<span class="hljs-params">self, n</span>):<br>        <span class="hljs-comment"># 获取第n个元素之前的元素</span><br>        <span class="hljs-keyword">return</span> self.values[:n]<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    num = FunctionalList([<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(num), num[<span class="hljs-number">0</span>])<br>    <span class="hljs-built_in">print</span>(num.head(), num.init(), num.last(), num.init(), num.drop(<span class="hljs-number">2</span>), num.take(<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure>

<pre><code>4 0
0 [0, 2, 4] 5 [0, 2, 4] [4, 5] [0]
</code></pre>
<h5 id="运算符相关的魔术方法"><a href="#运算符相关的魔术方法" class="headerlink" title="运算符相关的魔术方法"></a>运算符相关的魔术方法</h5><ul>
<li>比较运算符<ul>
<li>__ cmp __(self, other). </li>
<li>__ eq __(self, other)：定义了比较操作符 &#x3D;&#x3D; 的行为</li>
<li>__ ne __(self, other)：定义了比较操作符 !&#x3D; 的行为</li>
<li>__ it __(self, other)：定义了比较操作符 &lt;  的行为</li>
<li>__ gt __(self, other)：定义了比较操作符 &gt;  的行为</li>
<li>__ le __(self, other)：定义了比较操作符 &lt;&#x3D; 的行为</li>
<li>__ ge __(self, other)：定义了比较操作符 &gt;&#x3D; 的行为</li>
</ul>
</li>
<li>算数运算符<ul>
<li>__ add __(self, other)：实现加法运算</li>
<li>__ sub __(self, other)：实现减法运算</li>
<li>__ mul __(self, other)：实现乘法运算</li>
<li>__ floordiv __(self, other)：实现&#x2F;&#x2F;运算</li>
<li>__ div __(self, other)： python3中已废弃</li>
<li>__ truediv __(self, other)：</li>
<li>__ mod __(self, other)：实现取余运算</li>
<li>__ divmod __(self, other)：实现 divmod() 内建函数</li>
<li>__ pow __(self, other)：实现 **&#x2F;‘N’ 次方操作</li>
<li>__ lshift __(self, other)：实现位&#x2F;&lt;’&lt;’操作</li>
<li>__ rshift __(self, other)：实现位&#x2F;‘&gt;’&gt;操作</li>
<li>__ and __(self, other)：实现位&#x2F;‘&amp;’操作</li>
<li>__ or __(self, other)：实现位&#x2F;‘&#96;’操作</li>
<li>__ xor __(self, other)：实现位&#x2F;‘^’操作</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;比较运算符相关的魔术方法&#x27;&#x27;&#x27;</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        self.value = value<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__eq__&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self.value == other.value<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__ne__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__ne__&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self.value != other.value<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__it__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__it__&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self.value &lt; other.value<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__gt__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__gt__&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self.value &gt; other.value<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__le__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__le__&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self.value &lt;= other.value<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__ge__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__ge__&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self.value &gt;= other.value<br>    <br>    <span class="hljs-string">&#x27;&#x27;&#x27;算数运算符像概念的魔术方法&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__add__&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self.value + other.value<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    num1 = Number(<span class="hljs-number">2</span>)<br>    num2 = Number(<span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;num1 == num2 ? --&gt; &#123;&#125;\n&#x27;</span>.<span class="hljs-built_in">format</span>(num1 == num2))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;num1 != num2 ? --&gt; &#123;&#125;\n&#x27;</span>.<span class="hljs-built_in">format</span>(num1 != num2))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;num1 &lt;  num2 ? --&gt; &#123;&#125;\n&#x27;</span>.<span class="hljs-built_in">format</span>(num1 &lt; num2))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;num1 &gt;  num2 ? --&gt; &#123;&#125;\n&#x27;</span>.<span class="hljs-built_in">format</span>(num1 &gt; num2))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;num1 &lt;= num2 ? --&gt; &#123;&#125;\n&#x27;</span>.<span class="hljs-built_in">format</span>(num1 &lt;= num2))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;num1 &gt;= num2 ? --&gt; &#123;&#125;\n&#x27;</span>.<span class="hljs-built_in">format</span>(num1 &gt;= num2))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;num1 + num2 ? --&gt; &#123;&#125;\n&#x27;</span>.<span class="hljs-built_in">format</span>(num1 + num2))<br>    <br></code></pre></td></tr></table></figure>

<pre><code>__eq__
num1 == num2 ? --&gt; False

__ne__
num1 != num2 ? --&gt; True

__gt__
num1 &lt;  num2 ? --&gt; True

__gt__
num1 &gt;  num2 ? --&gt; False

__le__
num1 &lt;= num2 ? --&gt; True

__ge__
num1 &gt;= num2 ? --&gt; False

__add__
num1 + num2 ? --&gt; 5
</code></pre>
</div></article></div></main><footer><div class="paginator"><a href="/2020/07/15/code_Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9E%9A%E4%B8%BE%E7%B1%BB/" class="prev">PREV</a><a href="/2020/07/10/code_Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%A4%9A%E6%80%81/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2023 <a href="https://blog.lain.buzz"></a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/MikeCoder/hexo-theme-gandalfr" target="_blank">hexo-theme-gandalfr</a>.</p></div></footer></div><script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js" crossorigin="anonymous"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.js" crossorigin="anonymous"></script><script>$(document).ready(function() { hljs.configure({useBR: true}); $('pre').each(function(i, block) { hljs.highlightBlock(block); }); });</script></body></html>